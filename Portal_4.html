<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>Portal 4 - Snowfield Scene</title>
    <script id="vertex-shader" type="x-shader/x-vertex">
        attribute vec4 vPosition;
        attribute vec4 vColor;
        varying vec4 fColor;
        uniform mat4 modelViewMatrix;
        uniform mat4 projectionMatrix;
        void main() {
            gl_Position = projectionMatrix * modelViewMatrix * vPosition;
            fColor = vColor;
        }
    </script>
    <script id="fragment-shader" type="x-shader/x-fragment">
        precision mediump float;
        varying vec4 fColor;
        void main() {
            gl_FragColor = fColor;
        }
    </script>
    <script type="text/javascript" src="../Common/webgl-utils.js"></script>
    <script type="text/javascript" src="../Common/InitShaders.js"></script>
    <script type="text/javascript" src="../Common/MV.js"></script>
    <script type="text/javascript" src="Portal_4.js"></script>
    <script type="text/javascript">
        var gl;
        var points = [];
        var colors = [];

        var rotationX = -15;
        var rotationY = 5;
        var zoom = 1.0;

        var isDragging = false;
        var previousMouseX = 0;
        var previousMouseY = 0;

        var modelViewMatrixLoc;
        var projectionMatrixLoc;
        var vertexCount = 0;

        function buildScene() {
            createSnowField();
            createSnowCliffs();
            var gravestoneBaseY = -0.24;
            var gravestoneHeight = 0.13 * 1.15;
            var gravestoneWidth = 0.04 * 1.10;
            var gravestoneDepth = 0.02;
            var gravestoneColor = vec4(0.55, 0.54, 0.52, 1.0);
            var gravestoneCenters = [
                vec3(-0.09, gravestoneBaseY + gravestoneHeight / 2.0, -0.06),
                vec3(-0.09, gravestoneBaseY + gravestoneHeight / 2.0, 0.23),
                vec3(-0.01, gravestoneBaseY + gravestoneHeight / 2.0, -0.09),
                vec3(-0.01, gravestoneBaseY + gravestoneHeight / 2.0, 0.09)
            ];
            for (var g = 0; g < gravestoneCenters.length; g++) {
                createGravestones({
                    center: gravestoneCenters[g],
                    width: gravestoneWidth,
                    depth: gravestoneDepth,
                    height: gravestoneHeight,
                    color: gravestoneColor
                });
            }

            var baseY = -0.24;
            var minX = -0.45;
            var maxX = 0.35;
            var minZ = -0.45;
            var maxZ = 0.45;
            var x1 = minX + (maxX - minX) * (1 / 3) - 0.08;
            var x2 = minX + (maxX - minX) * (1 / 2) - 0.08;
            var x3 = minX + (maxX - minX) * (1.2) + 0.08 - 0.25 - 0.125;
            var rocks = [
                {
                    center: vec3(x1, baseY - 0.09 * 0.2, minZ + 0.13),
                    radius: 0.09,
                    color: vec4(0.78, 0.75, 0.72, 1.0),
                    seed: 1234
                },
                {
                    center: vec3(x2, baseY - 0.07 * 0.2, minZ + 0.13),
                    radius: 0.07,
                    color: vec4(0.72, 0.68, 0.65, 1.0),
                    seed: 2011
                },
                {
                    center: vec3(x3, baseY - 0.11 * 0.2, maxZ - 0.13),
                    radius: 0.11,
                    color: vec4(0.80, 0.77, 0.74, 1.0),
                    seed: 2899
                }
            ];
            for (var r = 0; r < rocks.length; r++) {
                createSnowRocks(rocks[r]);
            }
            createPortalLightBeam();
        }

        function setupCanvasInteractions(canvas) {
            canvas.addEventListener("mousedown", function (event) {
                isDragging = true;
                previousMouseX = event.clientX;
                previousMouseY = event.clientY;
            });

            canvas.addEventListener("mousemove", function (event) {
                if (!isDragging) {
                    return;
                }
                var deltaX = event.clientX - previousMouseX;
                var deltaY = event.clientY - previousMouseY;
                rotationY += deltaX * 0.5;
                rotationX += deltaY * 0.5;
                previousMouseX = event.clientX;
                previousMouseY = event.clientY;
            });

            canvas.addEventListener("mouseup", function () {
                isDragging = false;
            });

            canvas.addEventListener("mouseleave", function () {
                isDragging = false;
            });

            canvas.addEventListener("wheel", function (event) {
                event.preventDefault();
                if (event.deltaY < 0) {
                    zoom *= 1.1;
                } else {
                    zoom *= 0.9;
                }
                zoom = Math.max(0.3, Math.min(zoom, 3.0));
            }, { passive: false });
        }

        function initializeScene() {
            var canvas = document.getElementById("gl-canvas");
            gl = WebGLUtils.setupWebGL(canvas);
            if (!gl) {
                alert("WebGL isn't available");
                return;
            }

            points = [];
            colors = [];
            buildScene();
            vertexCount = points.length;

            gl.viewport(0, 0, canvas.width, canvas.height);
            gl.clearColor(0.10, 0.12, 0.18, 1.0);
            gl.enable(gl.DEPTH_TEST);
            gl.enable(gl.BLEND);
            gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

            var program = initShaders(gl, "vertex-shader", "fragment-shader");
            gl.useProgram(program);

            var cBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, cBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, flatten(colors), gl.STATIC_DRAW);
            var vColor = gl.getAttribLocation(program, "vColor");
            gl.vertexAttribPointer(vColor, 4, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(vColor);

            var vBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, vBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, flatten(points), gl.STATIC_DRAW);
            var vPosition = gl.getAttribLocation(program, "vPosition");
            gl.vertexAttribPointer(vPosition, 4, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(vPosition);

            modelViewMatrixLoc = gl.getUniformLocation(program, "modelViewMatrix");
            projectionMatrixLoc = gl.getUniformLocation(program, "projectionMatrix");

            setupCanvasInteractions(canvas);
            render();
        }

        function render() {
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

            var modelViewMatrix = mat4();
            modelViewMatrix = mult(modelViewMatrix, rotate(rotationY, vec3(0, 1, 0)));
            modelViewMatrix = mult(modelViewMatrix, rotate(rotationX, vec3(1, 0, 0)));

            var zoomFactor = 1.0 / zoom;
            var projectionMatrix = ortho(-zoomFactor, zoomFactor, -zoomFactor, zoomFactor, -6.0, 6.0);

            gl.uniformMatrix4fv(modelViewMatrixLoc, false, flatten(modelViewMatrix));
            gl.uniformMatrix4fv(projectionMatrixLoc, false, flatten(projectionMatrix));

            gl.drawArrays(gl.TRIANGLES, 0, vertexCount);

            requestAnimFrame(render);
        }

        window.onload = initializeScene;
    </script>
</head>
<body>
    <canvas id="gl-canvas" width="2048" height="2048">
        Oops ... your browser doesn't support the HTML5 canvas element
    </canvas>
</body>
</html>
